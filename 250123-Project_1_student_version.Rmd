---
title: "HUGEN 2072 Project 1"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

```

# Instructions

Below is a tutorial consisting of a mostly-completed QC pipeline and some prompts.

Project 1 has three components:

-   **Scripting/coding**: read through this file and complete the pipeline by contributing your code *where indicated*.

-   **Narrative**: knit the completed .Rmd to a code-integrated HTML report of your QC process and decisions.

    -   Your report must answer all the questions and perform all the tasks indicated in the instructions/prompts given for each step.

    -   You must submit a successfully-knitted HTML file and the `.Rmd` in order to earn a passing grade for this project.

    -   Set up your report to flow like an actual document you might show your supervisor to summarize the QC project, emphasizing what was done at each step rather than the code used to do it (e.g., how many samples/SNPs were filtered out at a given step?)

    -   **Submit your .Rmd and HTML to Canvas**

-   **Presentation**: you will make a 10 min (maximum) recording of yourself with Panopto in which you summarize this QC pipeline. Instructions will given on Canvas.

In each Part of this project you will implement one of the main steps of cleaning genotyping array data in a small dataset (note that we left a few steps out). You'll be shown how to use functions from the `{GWASTools}` package, and you'll supply a little of your own code to complete the pipeline that's been provided. At each step, you may be asked to create a filter for the data, to address errors/discrepancies, etc. Then for each step you'll make a short report (a few sentences and figures) explaining what you did.

Note that "sample" and "scan" are used interchangeably throughout this assignment, but that these are NOT synonymous with subject/participant/individual/etc. In this assignment, "SNP" and "probe" are used interchangeably, but in other contexts you should always remember the distinction.

**Since the pipeline below is incomplete, some of the R code chunks are set to `eval=FALSE` so that knitting to HTML will succeed. You will need to change them to `eval=TRUE` as you progress so that your knitted document shows the results of running each chunk.**

**It is expected that you will copy this file somewhere to your directory on the CRC cluster so that you can use the RStudio Server, where all the packages you need have been installed already.**

## Part 0 - Setup and Introduction to Annotation Data Frames

First, load the packages we'll be using.

```{r load_packages, message=F, eval=TRUE}

# Load the required packages for the project (Install them if necessary)

library("GWASTools", quietly = TRUE)
library("GWASdata", quietly = TRUE)
library("SNPRelate", quietly = TRUE)
library(tidyverse)

# Close any open GDS files before proceeding (think of this as starting off with
# a 'blank slate')

showfile.gds(closeall = T, verbose = T)

```

The array data (genotypes, intensities, and BAF/LRR information) for this project are contained in several GDS files; accompanying SNP and scan annotation are also provided as an `.RData` file.

The probe/SNP annotation is stored in an object called a scan annotation data frame, and the sample-level annotation is stored in a scan annotation data frame. Each of these objects is similar to an ordinary data frame. More precisely, a data frame is embedded within each. There is also accompanying metadata. To access the data and metadata, the `{GWASTools}` package provides several functions. Three basic functions you should familiarize yourself with are `getAnnotation()`/`pData()` (extracts a standard data frame containing the annotation), `getMetadata()`/`varMetadata()` (extracts a data frame of variable descriptions), and `getVariableNames()`/`varLabels()` (extracts a vector of just the variable names). You can also view a variable in one of these objects by using `$`, as you would for an ordinary data frame. You can also add new variables, but you need to be careful to update the metadata as well. Since we will be adding new variables in the process of cleaning our data, the following chunk of code shows you how to do this. Then you will practice looking at the annotation, and your task is to answer some questions about this data set.

First, load the annotation data (`annotation_data.RData`) that was provided with this project. **You need to supply the path to this file.**

```{r load_annotation, eval=TRUE}

# Load the probe (SNP) and sample annotation data frames, which have been saved
# in an .RData file

path_to_annotation_data <-
  "/ix1/hugen2072-2026s/p1/annotation_data.RData"
load(path_to_annotation_data)

# List the loaded objects

ls()

```

Here's a toy example showing you how to work with annotation data frames. **Read this carefully, since you'll need to do this throughout the assignment.**

```{r annotation_data_frame_example, eval=TRUE}

### How to add a new variable to an annotation data frame ###

#   Make a new copy of the SNP annotation (just for this example)

snp_annodf_temp <- snpAnnot

#   Notice that printing the object isn't that helpful

snp_annodf_temp

#   So extract the annotation itself (this is the 'normal' data frame embedded
#   in the SNP annotation data frame object). Now you can see the SNP-level
#   annotation

snp_data_temp <- getAnnotation(snp_annodf_temp)
head(snp_data_temp)

#   Add a new column to the annotation (an integer dummy variable)

snp_data_temp$dummy <- 1:nrow(snp_data_temp)

#   Now update the scan annotation object itself by replacing the what was in
#   the annotation "slot"

pData(snp_annodf_temp) <- snp_data_temp

#   You can see that the new column has been added

head(pData(snp_annodf_temp))

#   Extract the metadata so that it can be updated

meta_temp <- getMetadata(snp_annodf_temp)
meta_temp

#   Add a new row titled "dummy" with an appropriate labelDescription (note that
#   the metadata is a data frame with named rows but one column)

meta_temp["dummy", "labelDescription"] <- "This is a dummy variable"

#   Finally, replace the old metadata with the new metadata

varMetadata(snp_annodf_temp) <- meta_temp

#   Look at the data and metadata to make sure there the dummy variable has been
#   added

head(getAnnotation(snp_annodf_temp))
getMetadata(snp_annodf_temp)

#   Remove the temp files

rm(snp_annodf_temp, snp_data_temp, meta_temp)

```

Now we use `GdsGenotypeReader()` and `GdsIntensityReader()` to open the gds files that contain the array data. Then use `GenotypeData()` and `IntensityData()` to combine them with the SNP and sample annotation, since the functions we'll be using later require this information to be "packaged" together.

```{r load_array_data, eval=TRUE}

#   Get the genotypes from a gds file

genofile <-
  system.file("extdata", "illumina_geno.gds", package = "GWASdata")
gds_geno <- GdsGenotypeReader(genofile)

#   Combine the genotypes with the sample and SNP annotation

genoData <-
  GenotypeData(gds_geno, snpAnnot = snpAnnot, scanAnnot = scanAnnot)
genoData

#   Get the intensity data from a gds file

qxyfile <-
  system.file("extdata", "illumina_qxy.gds", package = "GWASdata")
gds_qxy <- GdsIntensityReader(qxyfile)

#   Combine with the sample and SNP annotation

qxyData <-
  IntensityData(gds_qxy, snpAnnot = snpAnnot, scanAnnot = scanAnnot)
qxyData

#   Get the BAF/LRR data from a gds file

blfile <-
  system.file("extdata", "illumina_bl.gds", package = "GWASdata")
gds <- GdsIntensityReader(blfile)

#   Combine the BAF/LRR data with the sample and SNP annotation

blData <-
  IntensityData(gds, snpAnnot = snpAnnot, scanAnnot = scanAnnot)
blData

```

## Part 0 - Report

Using the functions introduced above to help you, briefly describe the dataset in a few sentences. Answer the following questions. Whatever code you use to help answer these questions can go in the empty chunk that follows.

-   What is the difference between the scanID and subjectID variables? Why are they both provided?

The scanID is the unique ID used to identify the scans, whereas the subjectID is the identifier for the subjected the scan came from. It is possible for the same subjectID to have multiple scanIDs.

-   How many families are represented, and how many samples are from each family?

    | Families | Samples in Family |     |     |     |
    |---------:|------------------:|-----|-----|-----|
    |        4 |                 5 |     |     |     |
    |        5 |                 6 |     |     |     |
    |        9 |                 5 |     |     |     |
    |       12 |                 5 |     |     |     |
    |       28 |                 5 |     |     |     |
    |       58 |                 2 |     |     |     |
    |     1334 |                 6 |     |     |     |
    |     1340 |                 5 |     |     |     |
    |     1341 |                 9 |     |     |     |
    |     1344 |                 6 |     |     |     |

-   How many samples are of each sex?

    | Sex | Samples of each Sex |     |     |     |
    |:----|--------------------:|-----|-----|-----|
    | F   |                  35 |     |     |     |
    | M   |                  42 |     |     |     |

-   How many samples are from each population group?

    | Population Group | Samples in each population group |     |     |     |
    |:-----------------|---------------------------------:|-----|-----|-----|
    | CEU              |                               49 |     |     |     |
    | YRI              |                               28 |     |     |     |

-   How many samples are there? How many people did they come from?

    There are 77 samples from 43 different subject IDs.

-   How many SNPs are there?

    3300

-   Which chromosomes are represented? How many SNPs are on each?

    | Chromosomes | Number of SNPs for each Chromosome |     |     |     |
    |------------:|-----------------------------------:|-----|-----|-----|
    |          21 |                               1000 |     |     |     |
    |          22 |                               1000 |     |     |     |
    |          23 |                               1000 |     |     |     |
    |          24 |                                100 |     |     |     |
    |          25 |                                100 |     |     |     |
    |          26 |                                100 |     |     |     |

```{r part0_report, eval=TRUE}

#how many fam represented and how many samples from each fam

temp_scan <- getAnnotation(scanAnnot)

temp_scan %>% group_by(scanAnnot$family) %>% count()

#how many samps of each sex

temp_scan %>% group_by(scanAnnot$sex) %>% count()

#population group

temp_scan %>% group_by(scanAnnot$race) %>% count()

#how many samples and how many people did they come from 
nrow(temp_scan)

temp_scan %>% group_by(scanAnnot$subjectID) %>% count() %>% nrow()

#how many SNPs
temp_snp <- getAnnotation(snpAnnot)

nrow(temp_snp)

#how many chromos and how many SNPs on each
temp_snp %>% group_by(snpAnnot$chromosome) %>% count()
```

## Part 1 - Missing Call Rate for Samples and SNPs

The basic `{GWASTools}` functions for missingness are `missingGenotypeBySnpSex()` and `missingGenotypeByScanChrom()`. `missingGenotypeBySnpSex()` returns a list of three objects: `missing.counts`, `scans.per.sex`, and `missing.fraction`. Read the help file for this function so that you understand what information is contained in these and how the Y chromosome is treated by sex (where sex is as defined in the scan annotation). Similarly, `missingGenotypeByScanChrom()` returns `missing.counts`, `snps.per.chr`, and `missing.fraction`.

There are four basic missingness calculations to be done, in the following order.

1.  Calculate `missing.n1` = fraction of genotype calls missing over all samples (except that annotated ‘female’ individuals are excluded for Y chr SNPs)

2.  Calculate `missing.e1` = missing call rate per sample over all SNPs (excluding SNPs with all calls missing)

3.  Calculate `missing.n2` = call rate per SNP over all samples whose `missing.e1` is less than `0.05`

4.  Calculate `missing.e2` = missing call rate per sample over all SNPs with `missing.n2` values less than `0.05`

We'll want to store the missingness information in the annotation data frames as we proceed.

Here's how to calculate and store `missing.n1`.

```{r missing.n1, eval=TRUE}

### Using missingGenotypeBySnpSex to calculate missing.n1 ###

#   First look at some of the results

miss <- missingGenotypeBySnpSex(genoData)
names(miss)
head(miss$missing.counts)
miss$scans.per.sex
head(miss$missing.fraction)

#   We should make sure the snpIDs are in the same order in the annotation and
#   in the missingness report (miss$missing.fraction); they are

allequal(snpAnnot$snpID, as.numeric(names(miss$missing.fraction)))

#   Then go ahead and add missing.n1 as a new annotation data column, and update
#   the metadata

snpAnnot$missing.n1 <- miss$missing.fraction
varMetadata(snpAnnot)["missing.n1", "labelDescription"] <-
  paste(
    "fraction of genotype calls missing over all samples, except that females are excluded for Y chr SNPs"
  )

### Explore the missing call rate per probes a little more

#   Look at the distribution of missingness for all the probes

hist(
  snpAnnot$missing.n1,
  ylim = c(0, 100),
  xlab = "SNP missing call rate",
  main = "Missing Call Rate for All Probes"
)

#   How many SNPs are missing a genotype for every single sample? Apparently
#   there are 151 such SNPs

sum(snpAnnot$missing.n1 == 1)

#   Store a vector containing the snpIDs of all the SNPs with missingness of
#   100%

snpexcl <- snpAnnot$snpID[snpAnnot$missing.n1 == 1]

```

Now we calculate and store `missing.e1`. The steps are described in the comments below.

```{r missing.e1, eval=TRUE}

### Using missingGenotypeByScanChrom to calculate missing.e1

#   Apply missingGenotypeByScanChrom to genoData, using the snp.exclude option
#   to exclude these SNPs (why does it make sense to exclude those SNPs?)

miss <- missingGenotypeByScanChrom(genoData, snp.exclude = snpexcl)

#   Make sure the order of the scanIDs in the output from
#   missingGenotypeByScanChrom is the same as the order of the scanIDs in the
#   annotation data frame

allequal(names(miss$missing.fraction), scanAnnot$scanID)

#   Make a new column in scanAnnot called missing.e1 and store the per-scan
#   missingness from missingGenotypeByScanChrom there

scanAnnot$missing.e1 <- miss$missing.fraction

#   Update the scanAnnot metadata

varMetadata(scanAnnot)["missing.e1", "labelDescription"] <-
  "fraction of genotype calls missing over all snps with missing.n1<1 except that Y chr SNPs are excluded for females"

# We can check summary statistics and make a histogram, too

summary(scanAnnot$missing.e1)
hist(
  scanAnnot$missing.e1,
  xlab = "Fraction of missing calls over all probes",
  main = "Histogram of Sample Missing Call Rate for All Samples"
)

```

Now, supply your code to calculate and store `missing.n2`. The steps you should follow are described in the comments below.

```{r missing.n2, eval=TRUE}

### Now that missing.n1 and missing.e1 have been calculated, we can calculate missing.n2

#   Recall that missing.n2 = call rate per SNP over all samples whose missing.e1
#   is less than 0.05.

#   Since no sample had missing.e1 > 0.05 in this dataset, we don't actually
#   have to exclude any samples.

#   However, let's proceed as if there were some samples with missing.e1 > 0.05.

#   Make a vector of the scanIDs for the samples with high missing.e1.

scanexcl <- scanAnnot$scanID[scanAnnot$missing.e1 > 0.05]

#   Apply the missingGenotypeBySnpSex function again, using the scan.exclude
#   argument.

miss <- missingGenotypeBySnpSex(genoData, scan.exclude = scanexcl)

#   Store missing.n2 as a new column in snpAnnot.

snpAnnot$missing.n2 <- miss$missing.fraction

#   Update the metadata for snpAnnot!
varMetadata(snpAnnot)["missing.n2", "labelDescription"] <-
  paste(
    "fraction of genotype calls missing over all samples with missing.e1 < 0.05 except that females are excluded for Y chr SNPs"
  )

#   The labelDescription for missing.n2 should be "fraction of genotype calls
#   missing over all samples with missing.e1 < 0.05 except that females are
#   excluded for Y chr SNPs"

#   <Your code goes here>

```

Write code to calculate and store `missing.e2`. The steps you should follow are described in the comments below.

```{r missing.e2, eval=TRUE}

### Last, we calculate missing.e2

#   Recall missing.e2 = missing call rate per sample over all SNPs with
#   missing.n2 values less than 0.05

#   Store a vector with the snpIDs of all probes with missing.n2 >= 0.05

snpexcl <- snpAnnot$snpID[snpAnnot$missing.n2 >= 0.05]

#   Apply missingGenotypeByScanChrom to genoData again, using the snp.exclude
#   argument to exclude the SNPs with missing.n2 >= 0.05 (why do we do this?)

miss <- missingGenotypeByScanChrom(genoData, snp.exclude = snpexcl)

#   Make a new column in scanAnnot called missing.e2 to store the missingness
#   per-scan you just calculated

scanAnnot$missing.e2 <- miss$missing.fraction

#   Update the scanAnnot metadata

#   The labelDescription should say "fraction of genotype calls missing over all
#   snps with missing.n2 < 0.05 except that Y chr SNPs are excluded for females"

#   <Your code goes here>

varMetadata(scanAnnot)["missing.e2", "labelDescription"] <-
  "fraction of genotype calls missing over all snps with missing.n2 < 0.05 except that Y chr SNPs are excluded for females"
```

## Part 1 - Report

Summarize the filtering you've accomplished at this step. Include the following in your answer the following questions.

-   (First, make sure you've filled in the calculations of `missing.n2` and `missing.e2` in the chunks above.)

-   How many SNPs and samples were genotyped?

    There were 3149 SNPs without a 100% missingness for n2 and 77 samples without a 100% missingness for e2.

-   Briefly describe the purpose of doing this step in two rounds (why do we calculate both missingnesses twice?)

    The reason for doing this in 2 rounds is to do a general quality control for the genotypes and their missingness, then to refine the exclusion threshold for the second round.

-   What were the median, mean, and maximum per-sample missingness (use `missing.e2`)? Make a histogram of `missing.e2`.

    Median:

    ```         
    0.0006545
    ```

    Mean:

    ```         
    0.0018289 
    ```

    Max:

    ```         
    0.0242147
    ```

    See code below for histogram

-   How many samples had no missing calls at all (use `missing.e2`)?

    6 samples had missing call rates of 0.

-   Are the samples generally "good"? How many should be excluded from downstream analyses?

    I would say that the samples themselves seem "good" for downstream analysis, since the e2 seems generally low with the maximum value being 0.0242147. I would not exclude any of the samples.

-   How many SNPs had a 100% missing call rate (use `missing.n1`)?

    151 SNPs had a 100% missing call rate.

-   What are the median, mean, and maximum per-SNP missingnesses (use `missing.n2`)? How many SNPs are missing no calls at all?

    Median:

    ```         
    0.00000
    ```

    Mean:

    ```         
    0.04898
    ```

    Max:

    ```         
    1.00000
    ```

-   Make a histogram of `missing.n2`.

    see below

-   How many SNPs are filtered out and how many remain if you retain only SNPs with `missing.n2` \< 0.05?

    205 SNPs are filtered out of the data and 3095 SNPs remain after filtering for missing.n2 \< 0.05.

-   Make a histogram showing `missing.n2` for the remaining SNPs.

    see below

```{r part1_report}

# I worked with Shane Buckely and Vanessa Hong to figure out how to filter the missing SNPs, I did not realise I needed to getAnnotation() before I used filter()

#   <Your code goes here>
scan_data_temp <- getAnnotation(scanAnnot)
snp_data_temp <- getAnnotation(snpAnnot)

#used to look at data, but I commented out to make the html look nicer
#snp_data_temp
#scan_data_temp
getMetadata(scanAnnot)

#how many SNPs without missing 100 n2
num_snps <- snpAnnot %>% 
  getAnnotation() %>% 
  filter(snpAnnot$missing.n2 != 1)

nrow(num_snps)

#how many samples without missing 100 e2
num_scan <- scanAnnot %>% 
  getAnnotation() %>% 
  filter(scanAnnot$missing.e2 != 1)

nrow(num_scan)

#no missing calls e2
no_scan <- scanAnnot %>% 
  getAnnotation() %>% 
  filter(scanAnnot$missing.e2 == 0)

nrow(no_scan)

#missing call rate of 1 n1
no_snps <- snpAnnot %>% 
  getAnnotation() %>% 
  filter(snpAnnot$missing.n2 == 1)

nrow(no_snps)

# missing.n2 < 0.05 filter out and remain
tot_snps <- snpAnnot %>% 
  getAnnotation()
  
miss_snps <- snpAnnot %>% 
  getAnnotation() %>% 
  filter(snpAnnot$missing.n2 < 0.05)

nrow(miss_snps)
nrow(tot_snps) - nrow(miss_snps)


#e2 summary and histogram

summary(scanAnnot$missing.e2)

hist(
  scanAnnot$missing.e2,
  xlab = "Fraction of missing calls over all probes",
  main = "Histogram of Sample Missing Call Rate for All SNPs with a missing.n2 of less than 0.05"
)

#sum and histogram of n2
summary(snpAnnot$missing.n2)

hist(
  snpAnnot$missing.n2,
  xlab = "Fraction of missing calls over all probes",
  main = "Histogram of Sample Missing Call Rate per SNP over all samples whoes missing.e1 is less than 0.05"
)

#remaining SNPs histogram

filtered_snps <- snpAnnot %>% 
  getAnnotation() %>% 
  filter(snpAnnot$missing.n2 <= 0.05)

hist(
  filtered_snps$missing.n2,
  xlab = "Fraction of missing calls over all probes",
  main = "Histogram of Sample Missing Call Rate per SNP over all samples whoes missing.e1 is less than 0.05 and is less than 0.05"
)
```

## Part 2 - Inferred vs. Reported Sex and Relatedness

To investigate discrepancies in inferred vs. reported sex (and, possibly, sex chromosome aneuploidies), we will produce four plots that summarize each scan's heterozygosity and intensity for the sex chromosomes:

1.  Mean Y chromosome vs. mean X chromosome intensity

2.  Mean X chromosome heterozygosity vs. mean X chromosome intensity

3.  Mean Y chromosome intensity vs. mean X chromosome heterozygosity

4.  Mean X chromosome heterozygosity vs. autosomal heterozygosity

Recall that the intensity data was read in earlier as `qxyData`. Before making our graphs, we'll need to calculate the variables we want to plot. The basic function we'll use to do this is `meanIntensityByScanChrom()`, which will return a list of matrices. Read the help file of this function so that you understand the output. Heterozygosity is calculated with `hetByScanChrom()`.

```{r sex_check, eval=TRUE}

#   Look at the structure of the IntensityData object

qxyData

#   For each probe, there's a numerical ID, chromosome, position, rsID

#   The intensities (stored as variables called X and Y) are each essentially
#   3300×77 matrices (an X and Y intensity for each scan for every single probe)

#   (Don't confuse the *intensity variable names* _X_ and _Y_ in the IntensityData
#   object with the X and Y *chromosomes*!)

#   Apply the meanIntensityByScanChrom function to get the intensity averages.
#   (We're not going to use all of the output from this function)

inten.by.chrom <- meanIntensityByScanChrom(qxyData)

#   Extract the matrix containing the mean intensity for each chromosome for
#   each scan

names(inten.by.chrom)
mninten <- inten.by.chrom$mean.intensity

#   The matrix is 77x6 since there are 77 samples and 6 chromosomes represented
#   in the dataset

dim(mninten)
head(mninten)

#   We also need to calculate the X chromosome and autosome heterozygosities for
#   each sample before we can plot them

#   Apply hetByScanChrom to genoData (we need actual genotypes to calculate the
#   heterozygosity)

het.results <- hetByScanChrom(genoData)

#   The function calculates eachs scan's heterozygosity for each chromosome, and
#   also for the autosomes as a whole

#   We want to add X and autosome heterozygosity as new columns in scanAnnot

#   Make sure the scanIDs are in the right order first! (they are)

allequal(scanAnnot$scanID, rownames(het.results))

#   Extract the autosomal and X heterozygosity and store them in scanAnnot

scanAnnot$het.A <- het.results[, "A"]
scanAnnot$het.X <- het.results[, "X"]

#   Add appropriate metadata

varMetadata(scanAnnot)["het.A", "labelDescription"] <-
  "fraction of heterozygotes for autosomal SNPs"
varMetadata(scanAnnot)["het.X", "labelDescription"] <-
  "fraction of heterozygotes for X chromosome SNPs"

#   Before making the plots, there are a few things to do

#   We want to color the plotted points by annotated sex

#   But first, make sure that the order of the scanIDs (and hence the annotated
#   sexes) matches the order of the scanIDs in the data we'll plot

allequal(scanAnnot$scanID, rownames(mninten))

#   Now we assign each sex a color (male=blue, female=red)

#   Store the colors in a vector

xcol <- rep(NA, nrow(scanAnnot))
xcol[scanAnnot$sex == "M"] <- "blue"
xcol[scanAnnot$sex == "F"] <- "red"

#   We also want to count the number of SNPs getting included on the X and Y
#   chromosomes (which are coded as 23 and 25 in snpAnnot)

nx <- sum(snpAnnot$chromosome == 23)
ny <- sum(snpAnnot$chromosome == 25)

# Now make the plots

# All intensities

x1 <- mninten[, "X"]
y1 <- mninten[, "Y"]
main1 <- "Mean X vs \nMean Y Chromosome Intensity"

# Het on X vs X intensity

x2 <- mninten[, "X"]
y2 <- scanAnnot$het.X
main2 <-
  "Mean X Chromosome Intensity vs Mean X Chromosome Heterozygosity"

# Het on X vs Y intensity

y3 <- mninten[, "Y"]
x3 <- scanAnnot$het.X
main3 <-
  "MeanX Chromosome Heterozygosity vs Mean Y Chromosome Intensity"

# X vs A het

x4 <- scanAnnot$het.A[scanAnnot$sex == "F"]
y4 <- scanAnnot$het.X[scanAnnot$sex == "F"]
main4 <-
  "Mean Autosomal Heterozygosity vs Mean X Chromosome Heterozygosity"

# Make labels for axes/legends

cols <- c("blue", "red")
mf <- c("male", "female")
xintenlab <- paste("X intensity (n=", nx, ")", sep = "")
yintenlab <- paste("Y intensity (n=", ny, ")", sep = "")

# Make the 4 plots and add a legend

par(mfrow = c(2, 2))
plot(
  x1,
  y1,
  xlab = xintenlab,
  ylab = yintenlab,
  main = main1,
  col = xcol,
  cex.main = 0.8
)
legend("bottomleft",
       mf,
       col = cols,
       pch = c(1, 1),
       cex = 0.5)
plot(
  x2,
  y2,
  col = xcol,
  xlab = xintenlab,
  ylab = "X heterozygosity",
  main = main2,
  cex.main = 0.8
)
plot(
  x3,
  y3,
  col = xcol,
  ylab = yintenlab,
  xlab = "X heterozygosity",
  main = main3,
  cex.main = 0.8
)
plot(
  x4,
  y4,
  col = "red",
  xlab = "Autosomal heterozygosity",
  ylab = "X heterozygosity",
  main = main4,
  cex.main = 0.8
)
par(mfrow = c(1, 1))

```

## Part 2 - Report (Sex Check)

-   Describe any anomalies you see in the 4 plots above.

    In plots 1,2, and 3 there seems to be red (female) points in the blue (male) zone. The 4th plot also shows some female labeled points that sit at the 0 mark for X heterozygosity.

-   Figure out the scanIDs of any scans that look like outliers or possible instances of mislabeled sex. Include these IDs in your report and describe why they appear to be mislabeled.

    The scan IDs of the 2 SNPs that show up wrong on the graph is 325 and 326. They appear to be mislabeled because they are labeled as female in the sex column, but when looking at the X heterozygosity column they show up as 0. This indicates that there is 0 X heterozygosity leading us to believe that this is a sample with only 1 X chromosome. This contradicts the female label and can be thought of as mislabeled.

-   For the purposes of this assignment we will ASSUME that some scans have just had their sexes mislabeled. (In "real life", we would not just assume this, and we might instead flag these scans for removal from some downstream steps/analyses.)

-   Manually change the sex annotation for these scans in scanAnnot to "remove" the discrepancy. (Manually changing your data is risky and not generally recommended. Be careful!). In your report, state exactly what changes you made. Add a new column to scanAnnot indicating this, too (add appropriate metadata). Does anything in the pedigree structure make you more confident that this "fix" is correct? (Are these samples labeled as mothers or fathers?)

    When looking into the 1408 family pedigree the subject mislabeled as female is listed as the father of one of the other subjects in the pedigree. This makes me more confident in my fix to change the sex to M from F.

-   Remake the 4 plots above, using the "corrected" data (nothing should appear mislabeled now for this dataset).

    see below

-   How might you follow up on this "in real life"?

    To follow this up in real life I would contact the PI and alert them to the discrepancy and the change that I did along with the new column and column name.

```{r part2_report_sex_check}

#   <Your code goes here>

#outlier scanIDs 

#labeled F, but show up as M on the graphs 
sex_snps <- scanAnnot %>% 
  getAnnotation() %>% 
  filter(scanAnnot$sex == "F")

#filter for 0 X heterozygosity 
wrong_snps <- sex_snps %>%  
  filter(sex_snps$het.X == 0)

wrong_snps


#manually change the sex annotation - make new column indicating this 

scanAnnot$new_sex <- scanAnnot$sex

#325 and 326

pData(scanAnnot)$new_sex[pData(scanAnnot)$scanID == 325] <- "M"

pData(scanAnnot)$new_sex[pData(scanAnnot)$scanID == 326] <- "M"

varMetadata(scanAnnot)["new_sex", "labelDescription"] <-
  "Updated sex due to discrepancy of X heterozygosity and labeled sex"

getAnnotation(scanAnnot) %>% filter(family == 1408)

#remake the 4 plots above


#   Now we assign each sex a color (male=blue, female=red)

#   Store the colors in a vector

xcol <- rep(NA, nrow(scanAnnot))
xcol[scanAnnot$new_sex == "M"] <- "blue"
xcol[scanAnnot$new_sex == "F"] <- "red"

#   We also want to count the number of SNPs getting included on the X and Y
#   chromosomes (which are coded as 23 and 25 in snpAnnot)

nx <- sum(snpAnnot$chromosome == 23)
ny <- sum(snpAnnot$chromosome == 25)

# Now make the plots

# All intensities

x1 <- mninten[, "X"]
y1 <- mninten[, "Y"]
main1 <- "Mean X vs \nMean Y Chromosome Intensity"

# Het on X vs X intensity

x2 <- mninten[, "X"]
y2 <- scanAnnot$het.X
main2 <-
  "Mean X Chromosome Intensity vs Mean X Chromosome Heterozygosity"

# Het on X vs Y intensity

y3 <- mninten[, "Y"]
x3 <- scanAnnot$het.X
main3 <-
  "MeanX Chromosome Heterozygosity vs Mean Y Chromosome Intensity"

# X vs A het

x4 <- scanAnnot$het.A[scanAnnot$new_sex == "F"]
y4 <- scanAnnot$het.X[scanAnnot$new_sex == "F"]
main4 <-
  "Mean Autosomal Heterozygosity vs Mean X Chromosome Heterozygosity"

# Make labels for axes/legends

cols <- c("blue", "red")
mf <- c("male", "female")
xintenlab <- paste("X intensity (n=", nx, ")", sep = "")
yintenlab <- paste("Y intensity (n=", ny, ")", sep = "")

# Make the 4 plots and add a legend

par(mfrow = c(2, 2))
plot(
  x1,
  y1,
  xlab = xintenlab,
  ylab = yintenlab,
  main = main1,
  col = xcol,
  cex.main = 0.8
)
legend("bottomleft",
       mf,
       col = cols,
       pch = c(1, 1),
       cex = 0.5)
plot(
  x2,
  y2,
  col = xcol,
  xlab = xintenlab,
  ylab = "X heterozygosity",
  main = main2,
  cex.main = 0.8
)
plot(
  x3,
  y3,
  col = xcol,
  ylab = yintenlab,
  xlab = "X heterozygosity",
  main = main3,
  cex.main = 0.8
)
plot(
  x4,
  y4,
  col = "red",
  xlab = "Autosomal heterozygosity",
  ylab = "X heterozygosity",
  main = main4,
  cex.main = 0.8
)
par(mfrow = c(1, 1))

```

## Part 3 - Allelic Imbalance; BAF and LRR Plots

Here we want to look at B allele frequency (BAF) and log R ratio (LRR) plots using `chromIntensityPlot()`. Ordinarily, since there are 22 to 23 chromosomes to check for every sample, you would use a script that automatically detects aberrations in BAF and LRR. For this project, we'll pretend that our pipeline has already flagged one sample for a possible chromosomal anomaly.

```{r baflrr, eval=TRUE}

# Recall that earlier we read the intensity data into an IntensityData object
# called blData.

# The snp/scan annotation were attached as well.

# Suppose that chromosome 22 was flagged for scanID 286.

# Making the BAF/LRR plot is easy

#dev.off()
chromIntensityPlot(blData, scan.ids = 286, chrom.ids = 22)
par(mfrow = c(1, 1))

```

## Part 3 - Report

-   Describe the purpose of this step.

    The purpose of this step is to identify segments of the chromosomes that are not expected, such as CNV, runs of homozygosity, deletion/duplication, ect. The end goal is to exclude any genotypes or samples that have an unexpected copy number variation.

-   Show an example of a "normal" pair of BAF/LRR plots (choose any chromosome/scanID you want).

    see below

-   How would you detect trisomy 21 (i.e., describe briefly in words what the BAF/LRR plot would look like).

    To detect trisomy 21 you would run the BAF/LRR plot using chromosome 21. If there was a trisomy there would be 4 bands on the BAF plot and the LRR plot would be shifted up.

-   Suppose an individual had a balanced reciprocal translocation involving chromosome 2 and 4. What would you expect that individual's BAF/LRR plots would look like for those chromosomes?

    I used the <https://bredagenetics.com/balanced-translocations-what-to-do/> link to determine what exactly a balanced reciprocal translocation is to answer the question.

    A balanced reciprocal translocation would still have 3 bands on the BAF plot since there would still only be the option of homozygous for the two options or heterozygous. Even if the translocation changes the genotype sequence, there would still only be 2 alleles at a given basepair to measure intensity for. The LRR plot would stay around 0, since there would still be only 2 alleles at a given place to measure.

-   Suppose chromosome 22 in sample 286 was the only chromosome flagged for a possible anomaly in this dataset. Looking at the plot, do you notice anything strange? Can you suggest what kind of anomaly might be showing up? (There isn't any single answer that's certainly right! The purpose of this question is to check that you understand what the BAF and LRR plots "mean").

    Based on the plots, I can't find anything that I find particuarly strange, I did notice that there was no p-arm on the chromosome and the centromere was left off. There was one spot right after the 20 on the x-axis that looks like it is missing in the BAF and is spread around on the LRR. This may indicate some higher heterozygosity in the area which could be due to some admixture or contamination in that area of the chromosome.

-   Finally, suppose your pipeline has given you a list of the exact chromosomal segments showing possibly aneuploidies/anomalies in each sample. What would you recommend doing with the genotypes in those segments? (You're not being asked to implement this here - just say what you recommend doing.)

    I would plot the BAF/LRR for the chromosomal segments in each sample and look at the data. If it seems like there is a lot of anomalies in on specific segment I would exclude that segment from the report and if there are a lot of anomolies in one specific sample, I would exclude that sample from the report.

```{r part3_report}

#  <Your code goes here>
chromIntensityPlot(blData, scan.ids = 300, chrom.ids = 23)
par(mfrow = c(1, 1))
```

Me, Vanessa Hong, Shane Buckely, and Ceceilagh Pitstick all reviewed our code together after finishing the assignment.
